/* eslint-disable @typescript-eslint/no-use-before-define */

// A part of the code is taken from https://github.com/shimataro/deno-module-extension-resolver.

import fs from 'fs';
import path from 'path';
import glob from 'glob';
import cp from 'child_process';
import { remove, pathExists } from 'fs-extra';
import ts from 'typescript';

function findEntries(dirName: string): string[] {
  const source = `${dirName}/**/*.{ts,js}`;
  return glob.sync(source, {
    ignore: ['**/__specs__/**/*', '**/__tests__/**/*', '**/*.test.ts', '**/*.spec.ts'],
  });
}

function denoTransformer(context: ts.TransformationContext): ts.Transformer<ts.SourceFile> {
  return (rootNode: ts.SourceFile): ts.SourceFile => {
    const sourceFileName = rootNode.getSourceFile().fileName;
    return ts.visitNode(rootNode, visitorFactory(sourceFileName, context));
  };
}

function denolizeSourceFile(sourceFile: ts.SourceFile): string {
  const result = ts.transform(sourceFile, [denoTransformer]);
  result.dispose();

  const printer = ts.createPrinter();
  return printer.printFile(result.transformed[0]);
}

function visitorFactory(sourceFileName: string, context: ts.TransformationContext): ts.Visitor {
  return (node: ts.Node): ts.VisitResult<ts.Node> => {
    if (ts.isImportDeclaration(node) || ts.isExportDeclaration(node)) {
      return ts.visitEachChild(node, visitorResolverFactory(sourceFileName), context);
    } else {
      return ts.visitEachChild(node, visitorFactory(sourceFileName, context), context);
    }
  };
}

function visitorResolverFactory(sourceFileName: string): ts.Visitor {
  return (node: ts.Node): ts.VisitResult<ts.Node> => {
    if (!ts.isStringLiteral(node)) {
      return node;
    }
    const moduleName = node.text;
    const baseDir = path.dirname(sourceFileName);
    const resolvedModuleName = resolveModuleExtension(moduleName, baseDir);
    return ts.createStringLiteral(resolvedModuleName);
  };
}

function resolveModuleExtension(moduleName: string, baseDirName: string): string {
  if (!shouldResolveModuleExtension(moduleName)) {
    return moduleName;
  }

  const resolvedPath = resolveModulePath(moduleName, baseDirName);
  const resolvedName = `${resolvedPath}.ts`;
  if (isFile(resolvedName)) {
    // resolved
    const name = denolizeFileName(moduleName);
    return `${name}.ts`;
  }

  // not resolved
  console.warn(`[WARN] Module not resolved: ${moduleName}`);
  return moduleName;
}

function shouldResolveModuleExtension(moduleName: string): boolean {
  if (path.isAbsolute(moduleName)) {
    // absolute path
    return true;
  }
  if (moduleName.startsWith('.')) {
    // relative path
    return true;
  }

  return false;
}

function resolveModulePath(moduleName: string, baseDir: string): string {
  if (path.isAbsolute(moduleName)) {
    return moduleName;
  } else {
    return path.resolve(baseDir, moduleName);
  }
}

function denolizeFileName(name: string): string {
  return name.replace(/-/g, '_').replace(/\/index.ts$/, '/mod.ts');
}

function output(builtSource: string, fileName: string): string {
  const name = denolizeFileName(fileName);
  createDirectoriesIfNotExist(name);
  fs.writeFileSync(name, builtSource);
  return name;
}

function createDirectoriesIfNotExist(fileName: string): void {
  const dirName = path.dirname(fileName);
  if (isDirectory(dirName)) {
    // already exists
    return;
  }

  fs.mkdirSync(dirName, {
    recursive: true,
  });
}

function isDirectory(dirName: string): boolean {
  try {
    const stats = fs.statSync(dirName);
    return stats.isDirectory();
  } catch (err) {
    return false;
  }
}

function isFile(fileName: string): boolean {
  try {
    const stats = fs.statSync(fileName);
    return stats.isFile();
  } catch (err) {
    return false;
  }
}

function convertToDeno(srcDir: string, outDir: string): void {
  const entries = findEntries(srcDir);
  const program = ts.createProgram(entries, {});
  const autoGenerated: string[] = [];
  for (const entry of entries) {
    const sourceFile = program.getSourceFile(entry);
    if (sourceFile === undefined) {
      continue;
    }

    const denolizedCode = denolizeSourceFile(sourceFile);
    const dstFileName = path.join(outDir, path.relative(srcDir, entry));
    const file = output(denolizedCode, dstFileName).slice(outDir.length + 1);
    autoGenerated.push(file);
  }
  fs.writeFileSync(path.join(outDir, '.auto_generated'), autoGenerated.join('\n') + '\n');
  denoFmt(outDir);
}
function getAutGeneratedFiles(outDir: string): string[] {
  const autoGenerated = `${outDir}/.auto_generated`;
  return fs
    .readFileSync(autoGenerated)
    .toString()
    .split('\n')
    .filter((v) => !!v);
}

async function removeAutoGenerated(outDir: string): Promise<void> {
  const autoGenerated = `${outDir}/.auto_generated`;
  const exists = await pathExists(autoGenerated);
  if (exists) {
    const files = getAutGeneratedFiles(outDir);
    await Promise.all(files.map((file) => remove(`${outDir}/${file}`)));
  }
}

function gitPullLatest(workDir: string, repository: string): void {
  cp.execSync(`git clone ${repository} ${workDir}`);
  cp.execSync('git pull', {
    cwd: workDir,
  });
}

function denoFmt(workDir: string): void {
  cp.execSync('deno fmt', {
    cwd: workDir,
  });
  cp.execSync('deno fmt', {
    cwd: workDir,
  });
}

async function main(): Promise<void> {
  const srcDir = 'src';
  const outDir = 'deno';
  const repository = 'git@github.com:ts-graphviz/deno.git';

  await remove(outDir);
  gitPullLatest(outDir, repository);
  await removeAutoGenerated(outDir);
  convertToDeno(srcDir, outDir);
}

main();
